// <auto-generated>
//
//      This code was auto-generated on Friday, 1 January 2016 8:00 AM.
//
//      DO NOT EDIT THIS FILE.
//
//      Changes to this file may cause incorrect behaviour and will be lost if
//      the code is regenerated.
//
// </auto-generated>

#line 1 "sample"

#line 9 "sample"


// ReSharper disable All

using System.Collections.Generic;

namespace Sample
{
    public partial class SampleLexer
    {


        static readonly sbyte[] _sample_actions = new sbyte[] {
    0, 1, 0, 1, 1, 1, 2, 1,
    3, 1, 4
};

        static readonly sbyte[] _sample_key_offsets = new sbyte[] {
    0, 0
};

        static readonly char[] _sample_trans_keys = new char[] {
    '\u0020', '\u007b', '\u007d', '\u0009', '\u000d', (char) 0
};

        static readonly sbyte[] _sample_single_lengths = new sbyte[] {
    0, 3
};

        static readonly sbyte[] _sample_range_lengths = new sbyte[] {
    0, 1
};

        static readonly sbyte[] _sample_index_offsets = new sbyte[] {
    0, 0
};

        static readonly sbyte[] _sample_trans_targs = new sbyte[] {
    1, 1, 1, 1, 0, 0
};

        static readonly sbyte[] _sample_trans_actions = new sbyte[] {
    9, 5, 7, 9, 0, 0
};

        static readonly sbyte[] _sample_to_state_actions = new sbyte[] {
    0, 1
};

        static readonly sbyte[] _sample_from_state_actions = new sbyte[] {
    0, 3
};

        const int sample_start = 1;
        const int sample_first_final = 1;
        const int sample_error = 0;

        const int sample_en_main = 1;


#line 21 "sample"

        partial void Init()
        {

            {
                cs = sample_start;
                ts = -1;
                te = -1;
                act = 0;
            }

#line 25 "sample"
        }

        private IEnumerable<Token> GetTokens()
        {

            {
                sbyte _klen;
                sbyte _trans;
                int _acts;
                int _nacts;
                sbyte _keys;

                if (p == pe)
                    goto _test_eof;
                if (cs == 0)
                    goto _out;
                _resume:
                _acts = _sample_from_state_actions[cs];
                _nacts = _sample_actions[_acts++];
                while (_nacts-- > 0)
                {
                    switch (_sample_actions[_acts++])
                    {
                        case 1:
#line 1 "NONE"
                            { ts = p; }
                            break;
                        default: break;
                    }
                }

                _keys = _sample_key_offsets[cs];
                _trans = (sbyte)_sample_index_offsets[cs];

                _klen = _sample_single_lengths[cs];
                if (_klen > 0)
                {
                    sbyte _lower = _keys;
                    sbyte _mid;
                    sbyte _upper = (sbyte)(_keys + _klen - 1);
                    while (true)
                    {
                        if (_upper < _lower)
                            break;

                        _mid = (sbyte)(_lower + ((_upper - _lower) >> 1));
                        if (data[p] < _sample_trans_keys[_mid])
                            _upper = (sbyte)(_mid - 1);
                        else if (data[p] > _sample_trans_keys[_mid])
                            _lower = (sbyte)(_mid + 1);
                        else
                        {
                            _trans += (sbyte)(_mid - _keys);
                            goto _match;
                        }
                    }
                    _keys += (sbyte)_klen;
                    _trans += (sbyte)_klen;
                }

                _klen = _sample_range_lengths[cs];
                if (_klen > 0)
                {
                    sbyte _lower = _keys;
                    sbyte _mid;
                    sbyte _upper = (sbyte)(_keys + (_klen << 1) - 2);
                    while (true)
                    {
                        if (_upper < _lower)
                            break;

                        _mid = (sbyte)(_lower + (((_upper - _lower) >> 1) & ~1));
                        if (data[p] < _sample_trans_keys[_mid])
                            _upper = (sbyte)(_mid - 2);
                        else if (data[p] > _sample_trans_keys[_mid + 1])
                            _lower = (sbyte)(_mid + 2);
                        else
                        {
                            _trans += (sbyte)((_mid - _keys) >> 1);
                            goto _match;
                        }
                    }
                    _trans += (sbyte)_klen;
                }

                _match:
                cs = _sample_trans_targs[_trans];

                if (_sample_trans_actions[_trans] == 0)
                    goto _again;

                _acts = _sample_trans_actions[_trans];
                _nacts = _sample_actions[_acts++];
                while (_nacts-- > 0)
                {
                    switch (_sample_actions[_acts++])
                    {
                        case 2:
#line 5 "sample"
                            { te = p + 1; { yield return Emit(TokenType.LCurly); } }
                            break;
                        case 3:
#line 6 "sample"
                            { te = p + 1; { yield return Emit(TokenType.RCurly); } }
                            break;
                        case 4:
#line 7 "sample"
                            { te = p + 1; }
                            break;
                        default: break;
                    }
                }

                _again:
                _acts = _sample_to_state_actions[cs];
                _nacts = _sample_actions[_acts++];
                while (_nacts-- > 0)
                {
                    switch (_sample_actions[_acts++])
                    {
                        case 0:
#line 1 "NONE"
                            { ts = -1; }
                            break;
                        default: break;
                    }
                }

                if (cs == 0)
                    goto _out;
                if (++p != pe)
                    goto _resume;
                _test_eof: { }
                _out: { }
            }

#line 30 "sample"
        }
    }
}

// ReSharper restore All